### 问题汇总

#### 1、出现下述问题

- 原因：暂定是跨域问题，是服务端的问题

Request URL: httpsundefined/
Provisional headers are shown

这个问题字面意思是“显示了临时报文头”，浏览器第一次发送这个请求，请求被阻塞，未收到响应。当要求浏览器再次发送这个请求时，上个同样的请求都还没有收到响应，浏览器就会报这个警告。

简而言之，就是请求并没有发出去
是跨域问题，就是本文使用的是 file 协议。axios 使用的是 https 协议

#### 2、304 的概念

就是检查本地缓存是否已过期的请求，返回是未过期就是 304。
可能是客户端主动发起的（请求头是 ：ifxxx or ifxx），也可能是服务端发起的(etag or xx)

#### 3、better-scrolL 的 content 高度和实际不符

问题描述：<br>
**原因**

- 1、img 的加载是异步的。
- 2、钩子函数是同步的，普通数据和 dom 树结构渲染是同步的

**结果**

- 1、mounted 的时候，img 可能还不在页面上，不能用这个狗子函数实现刷新
- 2、dom 的标签和文字已经渲染好了，但是 img 还没来得及展示出来。导致 content 的高度不够。
- 3、better-scrolL 计算出来的可滚动距离出现问题，直观上就是图片出现了，但是拉不下去
- 4、某个元素到 顶部的距离（offetTop）计算的有问题。直观上就是 计算有问题
- 5、而且加载图片的接口，有些返回的会比较慢，有些返回的比较快，导致有时候会出现这个问题，有时候不会。

**解决思路**

- <1>、每个 img 用 @load 监听是否已加载到页面上，加载了后，并传递$emit或者$bus 给其他组件（home）这个信息，调用 scroll 的 refresh（）方法重新计算高度。

  缺点：图片过得时候，多次调用，影响性能

  解决缺点
  **_方案 1_**：当无法获取到要加载的图片的个数的时候，在每次调用 refresh（）方法的时候，加上 setTimeout ,setTimeout 赋值给全局变量，每次开启一个新定时器的时候都去清除前一个定时器，避免多次刷新

  **_方案 2_**:当资源数量确定，直接加个节流阀,num，每次加载了一个，num++，只要全部的数据加载完成了，才发起 emit()

- ~~<2>、直接在 updated()狗子函数里，调用 refresh（）方法。这样就能省去了组件通信的步骤，和使用定时器的步骤。~~

> 注意：方法 2 简单，但是有时候不奏效。目前不明白是为什么。比如这个方法用在轮播图的加载里，就是 ok，用在 detailImage 里就失效。

      猜测因为 updated 函数只执行了一次。

      问题：那么异步的数据变化，比如图片的加载不会引发 updated吗?--答案：不会

      详解：
      updated（）函数的执行时间是：只有当data数据发生变化，且要重新渲染到页面上去，才会触发。
      我们这里的image的异步加载，并不是属于data的变化，image的地址才是data，data不会改变，因此因此图片的加载不会触发updated 函数。
      有时候生效是因为，updated()执行的时候，轮播图的图片已经加载好了，而detail的image还有很多没加载的。

#### 4、在 detail 页面的很多图片哪里出现错误：Cannot read property ‘0‘ of undefined

**原因**
vue 中模板在渲染时候，读取对象中的某个对象的属性值时，这个对象中的某个属性并不存在（可能仍然在等待请求后台赋值），所以报错，接口请求到数据，数据会被正常渲染。
一般出现的场景：多层结构的数据 object 中包含 object 或 arrary

**流程大致是这样**：

1. data()中定义了对象 Obj

2. 模板渲染了 Obj 的 a 属性或值（a 属性并未给初始值，需要从后台渲染）。

3. 运行项目，编译模板（此时还没有请求接口，一般会在 **created()里请求**）

4. 控制台报错（如上）

5. 请求接口，拿到数据

6. 数据会正常渲染，报错也会存在在

**解决方案：**

1. 给对象设置初始值，适用于浅层数据，不超过 2 层（一般深层次访问肯定麻烦）

2. 加个 v-if 判断，没有值就不取，如下：注意此时要将**_这个判断加在最外层的 div_**
   ，且判断条件也是最外层的。因为不可能 a 这个对象只加载了个别属性，

```
v-if='Object.keys(a).length != 0 '
```

#### 5、如何实现 home 页面的位置保持：

- 1、加上标签 <keep-alive>
- 2、deactived() 里记录此时的 position.y
- 3、actived() 里调用 scroll 的 scrollT0(0,position.y,0)

#### 6、实现项目的组件化的时候注意使用封装的思想，如果从后端获取的数据不一致，则需要在获取数据的组件里提前处理好数据。

#### 7、组建通信的方式

- 1、\$emit props
- 2、$refs   $parent \$root
- 3、事件总线
  使用方式 1）main.js 里 Vue.prototype.$bus = new Vue()
              2) 发送  某个组件里，this.$bus.$emit('xx',params)   
              3) 接收  某个组件里，this.$bus.\$on('xx',(params)={})

#### 8、组件共享数据的方式

- 1、子组件 相当于借用，父子组件相互独立，数据需要传递
- 2、vuex 相当于共享，使用的数据或者方法指向的同一个地址，使用过程中共享变化
- 3、mixin 单纯的解决了代码复用，许多个组件若使用其中的数据，或者方法，都是相互独立的，互不影响。

  使用方法：创建一个 js 文件，export 一个 vue 实例。实例包含任何一个 vue 对象含有的 options,比如，methods getters data 导入语句 钩子函数。
  具体见 comment const.js,文件里的 options 内容会追加到对应的 options 里面。使用的时候正常

#### 9、detail 页面的 topBar 和 position 的联动

1、topbar 点击时，$emit（）出当前的index。
   2、detail页面接受index，并滚动到指定的位置
   3、在所有图片全部加载完成后，获取到指定element元素的 $el.offsetTop 并存储,就能完成指定位置的计算
4、监听页面滚动，当 position.y 属于每个范围内， ~~通过 props 传递对应的的 index 给 子组件~~，会报错，提示：子组件不能更改通过 props 传递过去的参数

直接使用 \$refs.name 来传递参数

#### 10、vuex 的使用

1、要在 store 的文件夹下的 index 文件里书写
2、import vue 和 vuex  
 3、 Vue.use(Vuex)
4、export default new Vuex.store({
xxx
})
5、在 main.js 里导入和放在 vue 实例里

#### 11、find 函数的使用

find 函数里返回第一个满足条件的元素
如果没有则是 undefined

```
arrary.find(item =>{
  return  item是否满足某个条件
})
```

#### 12、将 getters 转化为 computed 直接使用

1、import { mapGetters } from 'vuex'
import {mapActions} from 'vuex;
2、

```
computed:{
  ...mapGetters(['xx','xx']),
}

methods:{
  ...mapActions(['xx','xx'])
}

```

3、使用

```
  this.计算属性
  this.方法名()
```

#### 13、vuex 里面所有函数的参数，指向的都是原始数据的地址。能直接改变原数据的值。

    不像普通的方法，形参和实参，地址不一样，形参不能直接改变实参的值。只能通过return 来返回一个。
    同理  for of\foreach  等 一般用起来不是用来改变数据的，是用来计算合计或者筛选或者判断的用的

#### 14、vue 的 $refs  和 $el

###### 14.1、\$refs 的 2 种用法

      1、ref 加在普通的元素上，用this.$refs.name 获取到的是dom元素

      2、ref 加在子组件上，用 this.$refs.name  获取到的是组件实例，可以使用组件的所有方法和属性和接口。在使用方法的时候直接  this.$refs.name.方法（） 就可以使用了。

**注意点**
<br>

      1、ref 需要在 dom 渲染完成后才会有，在使用的时候确保 dom 已经渲染完成。比如在生命周期 mounted(){} 钩子中调用，或者在 this.\$nextTick(()=>{}) 中调用。

      2、如果 ref 是循环出来的，有多个重名，那么 ref 的值会是一个 【数组】 ，此时要拿到单个的 ref 只需要循环就可以了。

###### 14.2、$refs.name.$el 的用法

      $el 是获取vue实例（组件）关联的dom元素。就是上述的第二种情况的续集
      比如  this.topbarTargetY[3] = -this.$refs.detailRecommend.$el.offsetTop

#### 15、Vue.use(xx)

**使用方法：**

1、若传入的是个对象，那么这个对象必须有 install 方法，该 install 方法的参数是个 Vue 对象

2、若传入的是个函数，函数的参数是 Vue 对象

**原理解析**

1、先判断传入的插件是否是 函数或者对象
2、检查是否已经注册了这个插件（避免重复 use()），未注册则注册
3、处理 Vue.use 的入参，将第一个参数之后的参数归集,并在首部塞入 this 上下文，代码：
4、执行 install 函数或者函数本身
5、缓存插件
